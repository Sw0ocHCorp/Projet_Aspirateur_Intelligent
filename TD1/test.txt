function A*(start, goal, obstacles)
    // Initialize the open and closed lists
    openList = [start]
    closedList = []

    // Loop until the open list is empty
    while openList is not empty
        // Find the node in the open list with the lowest f value
        current = node in openList with lowest f value

        // If the current node is the goal, return the path
        if current is goal
            return path from start to goal

        // Remove the current node from the open list and add it to the closed list
        remove current from openList
        add current to closedList

        // Get all the current node's neighbors
        neighbors = all nodes adjacent to current

        // Loop through the current node's neighbors
        for each neighbor in neighbors
            // If the neighbor is in the closed list, ignore it
            if neighbor is in closedList
                continue

            // If the neighbor is an obstacle, ignore it
            if neighbor is in obstacles
                continue

            // If the neighbor is not in the open list, add it
            if neighbor is not in openList
                add neighbor to openList

            // Calculate the new g value for the neighbor
            newG = current.g + distance between current and neighbor

            // If the new g value is less than the neighbor's g value, update it
            if newG < neighbor.g
                neighbor.g = newG
                neighbor.h = estimated distance from neighbor to goal
                neighbor.f = neighbor.g + neighbor.h
                neighbor.parent = current


L'algorithme A* utilise une heuristique (h) pour estimer la distance restante pour atteindre le but. 
Il combine cette estimation avec la distance déjà parcourue (g) pour évaluer la fonction f = g + h pour chaque nœud. 
Il utilise ensuite cette fonction pour prioriser les nœuds à explorer.
Il utilise une liste ouverte pour stocker les nœuds qui ont été découverts mais pas encore examinés, et une liste fermée pour stocker les nœuds qui ont déjà été examinés. 
Il commence par ajouter le nœud de départ à la liste ouverte, puis itère jusqu'à ce que la liste ouverte soit vide. 
Il examine alors le nœud dans la liste ouverte avec la fonction f la plus faible, vérifie s'il s'agit de l'objectif et retourne le chemin si c'est le cas. Sinon, il retire ce nœud de la liste ouverte et l'ajoute à la liste fermée, puis examine chacun de ses voisins et met à jour leur fonction f si nécessaire.

Dans cette version de l'algorithme A*, on utilise une liste d'obstacles qui contient des positions dans l'espace de recherche qui ne peuvent pas être traversées.
Lorsque l'algorithme examine les voisins d'un nœud, il vérifie si un voisin se trouve dans la liste d'obstacles et ignore ce voisin s'il est présent.
Cela signifie que l'algorithme ne va pas explorer de voisins qui se trouvent dans des positions inaccessibles, ce qui permet de réduire le temps de recherche et d'éviter des chemins inutiles.